# 150. 逆波兰表达式求值

[力扣题目链接(opens new window)](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

根据 逆波兰表示法，求表达式的值。

有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

示例 1：

- 输入: ["2", "1", "+", "3", " * "]
- 输出: 9
- 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

示例 2：

- 输入: ["4", "13", "5", "/", "+"]
- 输出: 6
- 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

示例 3：

- 输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]

- 输出: 22

- 解释:该算式转化为常见的中缀算术表达式为：

  ```text
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5       
  = ((10 * (6 / (12 * -11))) + 17) + 5       
  = ((10 * (6 / -132)) + 17) + 5     
  = ((10 * 0) + 17) + 5     
  = (0 + 17) + 5    
  = 17 + 5    
  = 22    
  ```

  

逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。

该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。

#### 分析：

![150.逆波兰表达式求值](https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif)

**逆波兰表达式的意思就是每次遇到符号，取出栈顶的两个元素进行该符号的计算，然后再放回栈里。**

知道这个之后，其实就跟删除字符串里相邻的元素一样。



##### 注意：

1. 取出栈顶两个元素后的计算顺序，看上面的例子，是该13/5， 但是第一个top出来的元素是5，不要写错了。

2. string 转换成 int： 

   ```
   #include <string>  
   stoi(str);
   stoll(str);	//转换成long long
   ```

3. 超出范围后，要把int 改成long long

4. string 里面 取值1到9的话不知道能不能直接 tokens[i] >="1" && tokens[i]<="9"

   所以，最好用枚举的方式，枚举四个符号。



```cpp
#include <iostream>
using namespace std;
#include <stack>
#include <vector>
#include <string>

class Solution {
public:
	int evalRPN(vector<string>& tokens) {
		stack<long long> st;
		for (int i = 0; i < tokens.size(); i++) {
			if (tokens[i] =="+" || tokens[i]=="-" || tokens[i] == "*" || tokens[i] == "/") {
				long long a = st.top();
				st.pop();
				long long b = st.top();
				st.pop();
				if (tokens[i] == "+") st.push(b + a);
				if (tokens[i] == "-") st.push(b - a);
				if (tokens[i] == "*") st.push(b * a);
				if (tokens[i] == "/") st.push(b / a);				
			}
			else {
				st.push(stoll(tokens[i]));
			}
		}
		int res = st.top();
		st.pop();
		return res;
	}
};


int main() {
	string a[] = { "10","6","9","3","+","-11","*","/","*","17","+","5","+" };
	vector<string> v(a, a+sizeof(a)/sizeof(string));
	Solution solution;
	cout << solution.evalRPN(v) << endl;
	system("pause");
	return 0;
}
```

- 时间复杂度: O(n)
- 空间复杂度: O(n)

### 题外话

我们习惯看到的表达式都是中缀表达式，因为符合我们的习惯，但是中缀表达式对于计算机来说就不是很友好了。

例如：4 + 13 / 5，这就是中缀表达式，计算机从左到右去扫描的话，扫到13，还要判断13后面是什么运算符，还要比较一下优先级，然后13还和后面的5做运算，做完运算之后，还要向前回退到 4 的位置，继续做加法，你说麻不麻烦！

那么将中缀表达式，转化为后缀表达式之后：["4", "13", "5", "/", "+"] ，就不一样了，计算机可以利用栈来顺序处理，不需要考虑优先级了。也不用回退了， **所以后缀表达式对计算机来说是非常友好的。**

可以说本题不仅仅是一道好题，也展现出计算机的思考方式。

在1970年代和1980年代，惠普在其所有台式和手持式计算器中都使用了RPN（后缀表达式），直到2020年代仍在某些模型中使用了RPN。