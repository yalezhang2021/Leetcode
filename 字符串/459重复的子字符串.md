[459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

 

**示例 1:**

```
输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
```

**示例 2:**

```
输入: s = "aba"
输出: false
```

**示例 3:**

```
输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
```

 

**提示：**



- `1 <= s.length <= 104`
- `s` 由小写英文字母组成

### 分析：

可以用双指针，从头开始找第一次和第一个元素重复的位置，找到后以这个位置为开始，依次比较快指针和满指针的数值是否相等。如果相等，慢指针就回到0下标，从快指针的下一个元素再开始再比较一轮，依次重复直到比较完毕长字符串。如果此时子串正好也比较完了，那么就说明这个子串能构成长字符串。

不对，如果是 `aabaabaab`的话我只找第一个元素，下次重复就是aa，aa构不成长字符串。

### 移动匹配

当一个字符串s：abcabc，内部由重复的子串组成，那么这个字符串的结构一定是这样的：

![图一](https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104518.png)

也就是由前后相同的子串组成。

那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前面的子串做后串，就一定还能组成一个s，如图：

![图二](https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png)

所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。

当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

代码如下：

```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾
        if (t.find(s) != std::string::npos) return true; // r
        return false;
    }
};
```



- 时间复杂度: O(n)
- 空间复杂度: O(1)

不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。



我们学过KMP方法，**它的看家本领就是在一个串中找另一个串。**

寻找重复子串其实也是类似的，首先把前缀表搞搞好，这里面有各个位置为终点字符串的最长相同前后缀的长度。

最长相同前后缀和重复子串的关系是什么？

前缀： 是不包含最后一个字符的所有以第一个字符开头的连续子串。

后缀： 是不包含第一个字符的所有以最后一个字符结尾的连续子串。

![图三](https://code-thinking-1253855093.file.myqcloud.com/pics/20220728205249.png)

在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串s： abababab来举例，ab就是最小重复单位。

步骤一：因为 这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和 s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。

步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与 k[1]相同。

步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3] 相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与 s[4]s[5]相同。

步骤四：循环往复。

所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。

正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。

#### 简单推理

这里再给出一个数学推导，就容易理解很多。

假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是x，所以s是由n * x组成。

因为字符串s的最长相同前后缀的长度一定是不包含s本身，所以 最长相同前后缀长度必然是m * x，而且 n - m = 1，（这里如果不懂，看上面的推理）

所以如果 nx % (n - m)x = 0，就可以判定有重复出现的子字符串。

next 数组记录的就是最长相同前后缀 ， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。

最长相等前后缀的长度为：next[len - 1] + 1。(这里的next数组是以统一减一的方式计算的，因此需要+1，两种计算next数组的具体区别看这里：[字符串：KMP算法精讲 (opens new window)](https://programmercarl.com/0028.实现strStr.html))

数组长度为：len。

如果len % (len - (next[len - 1] + 1)) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。

**数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。**

**强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法**

如图：

![459.重复的子字符串_1](https://code-thinking.cdn.bcebos.com/pics/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2_1.png)

next[len - 1] = 7，next[len - 1] + 1 = 8，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。

(len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。



根据上面的推论，可以首先写出next数组的函数。然后从next数组中读取前缀表，当前缀表的值不为-1时（假设我们记第一个为-1），此时前面的长度len，如果能被s.size() 整除，则肯定是由重复子串构成的。这时看上面的图，其实根本不用for循环来算，求此时的最长相同前后缀，只需要求 next[s.size() - 1] 就可以了，然后让s.size() 减去这个值就得到了最小重复子串的长度。注意，next[s.size() - 1] != -1 非常重要，只有这样，才能说明这个字符串是由重复子串构成的。



另外再说一下关于j赋值为-1， next[0] 赋值为-1的问题，它相当于首先将所有next数组下标向右移动一位，在最左边添加了个-1， 这样的话就每次遇到冲突直接往前回退当前对应的next值就行了。不需要找前一位的。next[0]为-1说实话不懂，算法还是一样，看上图，可能就是方便了next前后缀是从0开始的吧。



OK但是不重要，会一种就可以了，我们就从0开始，嘿嘿，弄懂一套先用着。

```cpp
#include<iostream>
#include<vector>
using namespace std;

class Solution {
public:
	void getNext(vector<int>& next, const string& s) {
		int j = 0;
		next[0] = j;
		for (int i = 1; i < s.size(); i++) { //从1开始
			while (s[i] != s[j] && j > 0) {
				j = next[j - 1]; // 遇见冲突，从前一位对应的next往前回退
			}
			if (s[i] == s[j]) {
				j++;
			}
			next[i] = j;
		}
	}

	bool repeatedSubstringPattern(string s) {
		vector<int> next(s.size());
		getNext(next, s);
		int len = s.size();
		if (next[len - 1] != 0 && len % (len - (next[len - 1])) == 0) {
			return true;
		}
		return false;
	}
};

int main() {
	Solution solution;
	string s = "abac";
	cout << solution.repeatedSubstringPattern(s) << endl;
	return 0;
}
```

